<br>

As you go through the lectures and material for each day take notes in the provided sections. Not every detail is covered in this file. It's up to you to fill out this document with what you've learned as well as important material from lectures and videos.

<br>
<br>


# Monday, W15, D1

## REACT CLASS COMPONENTS

<br>

## What are class components?

- Class Components were used before React 16. Many of you will work with codebases that were built using class based React. One of your jobs might be converting class components into functional components.
- They cannot use hooks and have specific methods that manage component state and state side effects.
- The useEffect hook replaces the class component lifecycle methods.
- Remember, event handler functions you create must be bound to that component's context. This is needed when you are passing in the event handler and not invoking it. If you are using an arrow function because you need to invoke the handler with an argument, ES6 implicit binding for arrow functions precludes the need to explicitly bind the function. That being said, it is always a good idea to bind your event handlers just in case you need to use them uninvoked. Bind them in the constructor method of your class.

Syntax:

```js
class MyComponent extends React.Component {
  constructor(props){
    super(props)
    this.state = {
      stateData = 'click me!'
    }

    this.handleSubmit = this.handleSubmit.bind(this)
  }

  handleSubmit(e){
    console.log(this)
  }

  render(){
    return (
      <>
        <button onClick={this.handleSubmit}>{this.state.stateData}</button>
      </>
    )
  }
}
```

<br>

Your notes and code here:

- <notes/codeblocks>

<br>
<hr>

## Class Component State

- Because we are working in a class, state for each component instance will be defined in the constructor method as `this.state = {}`. Each key in the state object is known as a 'slice'.
- As you probably already assume, to access this state object in your class instance you will use `this.state.<key you defined>`.
- Never mutate this state object directly. You are given a setter function for this purpose, as was the case with hooks:
  - `this.setState((state, props) => stateChange)`.
- As with all state changes in React, in order for React to detect a change it must detect a new reference in memory. Always return a new reference in memory any time you call a state setter, whether you are using class components or hooks.
- Even if you have multiple slices of state in your component, your setter should only return the key/value pair you want to change. React will merge this object with the current state object.

Syntax:

```js
class InputComponent extends React.Component {
  constructor(props){
    super(props)
    this.state = { inputValue: '' }
  }
  render(){
    return(
      <input
        value={inputValue}
        onChange={this.setState( => { inputValue: e.target.value })}
        />
    )
  }
}
```

<br>

Your notes and code here:

- <notes/codeblocks>

<br>
<hr>

## How to use Logical Operators outside of boolean context

- logical AND `<boolean> && <value to return>`
- logical OR `<return if truthy> || <default value>`
- nullish coalescing `<null or undefined returns other side> ?? <value to return>`

Purpose

- They return the first truthy value in the expression.
- They are used for short-circuiting and conditional rendering.

<br>

Your notes and code here:

- <notes/codeblocks>

<br>
<hr>

## How to create new keys in objects:

Variable as key:

- `obj[variable] = value`

String as a key:

- `obj["string"] = value`
- `obj.string = value`

<br>

Your notes and code here:

- <notes/codeblocks>

<br>
<hr>

## How to remove keys from objects:

- `delete object[key]`

<br>

Your notes and code here:

- <notes/codeblocks>

<br>
<hr>

## Know the difference between value types vs reference types in memory

Value Types:

- Variables are stored containing a literal value

Reference Types:

- Variables are stored as only a hexadecimal reference to the original object in memory that holds the value

<br>

Your notes and code here:

- <notes/codeblocks>

<br>
<hr>

## How to shallow copy vs deep copy an object

Shallow copy:

- `{...obj}`
- `[...array]`

Deep copy:

- `JSON.stringify()` then `JSON.parse()`
- This technique is the easiest way to deep copy, but it only works on JSON serializable data and literal values. For complex objects and references, you'll need a custom function that is possibly recursive. Best to use Lodash library.

What are the differences between a shallow copy and a deep copy of an object?

<br>

Your notes and code here:

- <notes/codeblocks>

<br>
<hr>
<br>

We will mention these concepts throughout Mod 5 with the expectation that you already know how to implement them. **Study them**.
You **must** be fluent in the above concepts to succeed in this mod. Some are familiar to you, others not. No matter your current familiarity with the above concepts, take some time to look study them through Google, MDN or AppAcademy Open. Proficiency with these basics is absolutely vital to not only this Mod, but also your career.
